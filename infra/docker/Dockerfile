# Multi-stage Dockerfile for games
# Optimized for UV package manager with security and performance best practices
# 
# Build stages:
# 1. base       - Common base configuration
# 2. builder    - Dependency installation and compilation
# 3. development - Development environment with all tools
# 4. production - Minimal production runtime
# 
# Usage:
#   docker build -t games:latest .                    # Production build
#   docker build --target development -t games:dev .  # Development build

# ============================================================================
# STAGE 1: BASE CONFIGURATION
# ============================================================================

FROM python:3.11-slim as base

# Set environment variables for Python and UV
ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PYTHONIOENCODING=utf-8 \
    LANG=C.UTF-8 \
    LC_ALL=C.UTF-8 \
    # UV configuration
    UV_COMPILE_BYTECODE=1 \
    UV_LINK_MODE=copy \
    UV_PYTHON_DOWNLOADS=never \
    UV_CACHE_DIR=/opt/uv-cache \
    # Application configuration
    PYTHONPATH="/app/src:$PYTHONPATH" \
    PATH="/app/.venv/bin:$PATH"

# Install system dependencies and security updates
RUN apt-get update && apt-get install -y \
    # Build essentials for compiling Python packages
    build-essential \
    # Version control
    git \
    # Network utilities
    curl \
    wget \
    # Process management
    procps \
    # Security and certificates
    ca-certificates \
    gnupg \
    # Cleanup package cache
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/* \
    && rm -rf /tmp/* \
    && rm -rf /var/tmp/*

# Install UV package manager
COPY --from=ghcr.io/astral-sh/uv:latest /uv /bin/uv

# Create application user for security (non-root)
RUN groupadd -r appuser && \
    useradd -r -g appuser -d /app -s /bin/bash appuser && \
    mkdir -p /app /opt/uv-cache && \
    chown -R appuser:appuser /app /opt/uv-cache

# Set working directory
WORKDIR /app

# ============================================================================
# STAGE 2: BUILDER (Dependency Installation)
# ============================================================================

FROM base as builder

# Copy UV configuration and dependency files
COPY pyproject.toml uv.lock* ./

# Create virtual environment and install dependencies
# Use --no-dev for production dependencies only
RUN --mount=type=cache,target=/opt/uv-cache,uid=1000,gid=1000 \
    uv sync --frozen --no-dev --no-install-project

# Copy source code
COPY --chown=appuser:appuser . .

# Install the application package
RUN --mount=type=cache,target=/opt/uv-cache,uid=1000,gid=1000 \
    uv pip install --no-deps -e .

# ============================================================================
# STAGE 3: DEVELOPMENT ENVIRONMENT
# ============================================================================

FROM base as development

# Install additional development system dependencies
RUN apt-get update && apt-get install -y \
    # Development tools
    vim \
    nano \
    htop \
    # Debugging tools
    strace \
    gdb \
    # Network debugging
    netcat-openbsd \
    telnet \
    # File utilities
    tree \
    less \
    # Cleanup
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# Switch to application user
USER appuser

# Copy dependency files
COPY --chown=appuser:appuser pyproject.toml uv.lock* ./

# Install all dependencies including development tools
RUN --mount=type=cache,target=/opt/uv-cache,uid=1000,gid=1000 \
    uv sync --frozen --all-extras

# Copy source code
COPY --chown=appuser:appuser . .

# Install the application in development mode
RUN --mount=type=cache,target=/opt/uv-cache,uid=1000,gid=1000 \
    uv pip install --no-deps -e .

# Install additional development tools
RUN uv pip install \
    # Interactive debugging
    ipython \
    ipdb \
    # Code formatting and linting
    ruff \
    mypy \
    # Testing tools
    pytest \
    pytest-cov \
    pytest-xdist \
    # Profiling tools
    py-spy \
    memory-profiler \
    # Jupyter for data exploration
    jupyter \
    jupyterlab

# Expose common development ports
EXPOSE 8000 8080 5000 3000 8888 8501

# Health check for development
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD python -c "import games; print('Development environment healthy')" || exit 1

# Development command (interactive shell)
CMD ["/bin/bash"]

# ============================================================================
# STAGE 4: PRODUCTION RUNTIME
# ============================================================================

FROM base as production

# Install only production system dependencies
RUN apt-get update && apt-get install -y \
    # Minimal runtime dependencies
    ca-certificates \
    # Process management for production
    dumb-init \
    # Monitoring utilities
    procps \
    # Cleanup
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/* \
    && rm -rf /tmp/* \
    && rm -rf /var/tmp/* \
    # Remove build tools to reduce attack surface
    && apt-get purge -y \
        build-essential \
        git \
        curl \
        wget \
    && apt-get autoremove -y

# Switch to application user early for security
USER appuser

# Copy virtual environment from builder stage
COPY --from=builder --chown=appuser:appuser /app/.venv /app/.venv

# Copy application source code
COPY --from=builder --chown=appuser:appuser /app/src /app/src
COPY --from=builder --chown=appuser:appuser /app/pyproject.toml /app/
COPY --from=builder --chown=appuser:appuser /app/README.md /app/

# Copy additional runtime files if they exist
COPY --from=builder --chown=appuser:appuser /app/alembic.ini /app/ 2>/dev/null || true
COPY --from=builder --chown=appuser:appuser /app/migrations /app/migrations/ 2>/dev/null || true

# Create necessary runtime directories
RUN mkdir -p \
    /app/logs \
    /app/data \
    /app/tmp \
    /app/uploads

# Set proper permissions
RUN chmod -R 755 /app && \
    chmod -R 777 /app/logs /app/data /app/tmp /app/uploads

# Expose application port
EXPOSE 8000

# Add labels for better container management
LABEL maintainer="games Team <team@example.com>" \
      org.opencontainers.image.title="games" \
      org.opencontainers.image.description="games - A modern Python application" \
      org.opencontainers.image.vendor="Your Organization" \
      org.opencontainers.image.version="0.1.0" \
      org.opencontainers.image.created="$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
      org.opencontainers.image.source="https://github.com/yourusername/games" \
      org.opencontainers.image.documentation="https://games.readthedocs.io/" \
      org.opencontainers.image.licenses="MIT"

# Health check for production
HEALTHCHECK --interval=30s --timeout=30s --start-period=10s --retries=3 \
    CMD python -c " \
        import sys, socket; \
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM); \
        result = sock.connect_ex(('localhost', 8000)); \
        sock.close(); \
        sys.exit(0 if result == 0 else 1) \
    " || exit 1

# Use dumb-init for proper signal handling
ENTRYPOINT ["dumb-init", "--"]

# Default production command
CMD ["uv", "run", "python", "-m", "games", "--host", "0.0.0.0", "--port", "8000"]

# ============================================================================
# ALTERNATIVE COMMANDS
# ============================================================================

# To run specific commands, override CMD:
# 
# Web server with Uvicorn:
# CMD ["uv", "run", "uvicorn", "games.main:app", "--host", "0.0.0.0", "--port", "8000"]
#
# Gunicorn for production:
# CMD ["uv", "run", "gunicorn", "games.main:app", "-w", "4", "-k", "uvicorn.workers.UvicornWorker", "--bind", "0.0.0.0:8000"]
#
# Database migrations:
# CMD ["uv", "run", "alembic", "upgrade", "head"]
#
# Background worker:
# CMD ["uv", "run", "python", "-m", "games.worker"]
#
# CLI application:
# CMD ["uv", "run", "games", "--help"]

# ============================================================================
# DOCKER COMPOSE INTEGRATION
# ============================================================================

# This Dockerfile is designed to work with docker-compose.yml:
#
# version: '3.8'
# services:
#   app:
#     build: .
#     ports:
#       - "8000:8000"
#     environment:
#       - DATABASE_URL=postgresql://user:pass@db:5432/games
#       - REDIS_URL=redis://redis:6379/0
#     depends_on:
#       - db
#       - redis
#     volumes:
#       - ./data:/app/data
#       - ./logs:/app/logs
#
#   app-dev:
#     build:
#       context: .
#       target: development
#     ports:
#       - "8000:8000"
#       - "8888:8888"  # Jupyter
#     volumes:
#       - .:/app
#       - uv-cache:/opt/uv-cache
#     environment:
#       - ENVIRONMENT=development
#
#   db:
#     image: postgres:15
#     environment:
#       - POSTGRES_DB=games
#       - POSTGRES_USER=user
#       - POSTGRES_PASSWORD=pass
#     volumes:
#       - postgres_data:/var/lib/postgresql/data
#
#   redis:
#     image: redis:7-alpine
#
# volumes:
#   postgres_data:
#   uv-cache:

# ============================================================================
# BUILD OPTIMIZATION NOTES
# ============================================================================

# Build optimizations implemented:
#
# 1. Multi-stage builds:
#    - Separate builder stage for dependencies
#    - Minimal production runtime
#    - Development stage with full tooling
#
# 2. Layer caching:
#    - Dependencies installed before source code copy
#    - UV cache mounted for faster rebuilds
#    - System packages cached separately
#
# 3. Security:
#    - Non-root user execution
#    - Minimal production dependencies
#    - Regular security updates
#    - Proper file permissions
#
# 4. Performance:
#    - UV for fast dependency resolution
#    - Bytecode compilation enabled
#    - Optimized Python settings
#    - Proper signal handling with dumb-init
#
# 5. Observability:
#    - Health checks for both dev and prod
#    - Proper labels for container management
#    - Structured logging support
#    - Debug tools in development stage

# ============================================================================
# USAGE EXAMPLES
# ============================================================================

# Build production image:
# docker build -t games:latest .
#
# Build development image:
# docker build --target development -t games:dev .
#
# Run production container:
# docker run -p 8000:8000 games:latest
#
# Run development container with volume mount:
# docker run -it -p 8000:8000 -v $(pwd):/app games:dev
#
# Run with environment variables:
# docker run -p 8000:8000 -e DATABASE_URL=postgresql://... games:latest
#
# Run interactive shell in development:
# docker run -it games:dev /bin/bash
#
# Run tests in container:
# docker run games:dev uv run pytest
#
# Run with docker-compose:
# docker-compose up --build
#
# Development with hot reload:
# docker-compose -f docker-compose.dev.yml up

# ============================================================================
# SECURITY CONSIDERATIONS
# ============================================================================

# Security measures implemented:
#
# 1. Non-root execution:
#    - Application runs as 'appuser' (non-root)
#    - Proper file ownership and permissions
#    - Reduced attack surface
#
# 2. Minimal attack surface:
#    - Multi-stage builds remove build tools from production
#    - Only necessary packages in production
#    - Regular security updates
#
# 3. Dependency security:
#    - UV lock files ensure reproducible builds
#    - Security scanning can be integrated into CI
#    - Official base images from trusted sources
#
# 4. Runtime security:
#    - Proper signal handling prevents zombie processes
#    - Health checks for monitoring
#    - Structured logging for audit trails
#
# 5. Network security:
#    - Explicit port exposure
#    - Application binds to all interfaces securely
#    - Environment variable configuration

# ============================================================================
# MAINTENANCE AND MONITORING
# ============================================================================

# For production deployment, consider:
#
# 1. Resource limits:
#    - Set memory and CPU limits in deployment
#    - Configure appropriate health check timeouts
#    - Monitor resource usage
#
# 2. Logging:
#    - Configure structured logging
#    - Set up log aggregation
#    - Monitor application metrics
#
# 3. Updates:
#    - Regular base image updates for security
#    - Dependency updates through UV
#    - Automated vulnerability scanning
#
# 4. Backup:
#    - Data volume backup strategies
#    - Database backup integration
#    - Configuration backup
#
# 5. Scaling:
#    - Horizontal scaling with load balancers
#    - Database connection pooling
#    - Caching strategies with Redis